#!groovyâ€‹

// Example template for webMethods API Gateway Devops pipeline
// This version requires an Integration Server to be running and
// the package JcAPITools to be installed.
// 
// All API interaction is with this Integration Server.

// Developed by John Carter (john.carter@softewareag.com)
// December 2019
// Last Modified
// January 2020


// returns a list of API's hosted by given Integration Server
// only valid for API's developed using 'API Descriptors'

// server - hostaname and port of Integration Server hosting JcAPITools package
// authorizer - string label of jenkins defined credentials for Integration Server
// returns - list of Objects {name, basePath, swagger, package}

def getServerAPIs(server, authorizer) {

	response = httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'GET', 
				ignoreSslErrors: true, 
				url: "${server}/rad/jc.api:api/tools/local", 
				validResponseCodes: '200:201'

	jsn = readJSON file: '', text: "${response.content}"

	return jsn.apis
}

// register the API on the given Integration Server to the specified API gateway

// server - hostaname and port of Integration Server hosting JcAPITools package
// authorizer - string label of jenkins defined credentials for Integration Server
// api_name - name of API to be registered in API Gateway
// api_maturity - maturity label to be associated with API
// api_group - comma separated string list of all groups to be associated with API
// api_version - default version to use if creating the API for the first time
// api_endpoint - replaces existing endpoint in source swagger
// api_app - default app to be associated with API, created if it doesn't yet exist.
//
def registerServerAPI(server, authorizer, api_name, api_maturity, api_group, api_version, api_endpoint, api_app) {

	def body = """ {
			"apiGatewayURL": "${APIGW_SERVER}",
			"apiGatewayCredentials": "${APIGW_CREDENTIALS}",
			"apiAllowUpdate": "${APIGW_ALLOW_UPDATE}",
			"apiMaturity": "${api_maturity}",
			"apiGroup": "${api_group}",
			"apiVersion": "${api_version}",
			"apiEndpoint": "${api_endpoint}",
			"defaultApp": "${api_app}"
  		}"""

	response = httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'POST', 
				requestBody: body,
				ignoreSslErrors: true, 
				url: "${server}/rad/jc.api:api/tools/local/publish?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}", 
				validResponseCodes: '200:201'

	jsn = readJSON file: '', text: "${response.content}"

	return jsn.apis;
}

// Registers the API for the given url to the specified API gateway
// server - hostaname and port of Integration Server hosting JcAPITools package
// authorizer - string label of jenkins defined credentials for Integration Server
// swagger_url - remore url to be used as source of swagger definition
// swagger_credentials - optional credentials to be used when connecting to remote url.
// api_name - name of API to be registered in API Gateway
// api_maturity - maturity label to be associated with API
// api_group - comma separated string list of all groups to be associated with API
// api_version - default version to use if creating the API for the first time
// api_endpoint - replaces existing endpoint in source swagger
// api_app - default app to be associated with API, created if it doesn't yet exist.
//
def registerUrlBasedAPI(server, authorizer, swagger_url, swagger_credentials, api_name, api_maturity, api_group, api_version, api_endpoint, api_app) {

	def body = """ {
		"apiServer": {
			"apiGatewayURL": "${APIGW_SERVER}",
			"apiGatewayCredentials": "${APIGW_CREDENTIALS}",
			"apiAllowUpdate: "${api_gateway_update}",
			"apiMaturity": "${api_maturity}",
			"apiGroup": "${api_group}",
			"apiVersion": "${api_version}",
			"apiEndpoint": "${api_endpoint}",
			"defaultApp": "${api_app}"
  		},
  		"from": {
  			"swaggerUrl": "${swagger_url}",
  			"swaggerUser": "${swagger_user}",
  			"swaggerPassword: "${swagger_password}
  		}
	}"""

	httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'POST', 
				requestBody: body,
				ignoreSslErrors: true, 
				url: "${server}/rad/jc.api:api/tools/publish?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}", 
				validResponseCodes: '200:201'
}

// registers the API for the given url to the specified API gateway
// as above but git replaces source, will potentially register multiple API's if more than one file 
// found at 'git_path' location.
def registerGitBasedAPIs(server, authorizer, git_url, git_user, git_password, git_path, api_maturity, api_group, api_version, api_app) {

	def body = """ {
		"apiServer": {
			"apiGatewayURL": "${APIGW_SERVER}",
			"apiGatewayCredentials": "${APIGW_CREDENTIALS}",
			"apiAllowUpdate: "${api_gateway_update}",
			"apiMaturity": "${api_maturity}",
			"apiGroup": "${api_group}",
			"apiVersion": "${api_version}",
			"defaultApp": "${api_app}"
  		},
  		"from": {
  			"gitUrl": "${git_url}",
  			"gitUser": "${git_user}",
  			"gitToken": "${git_token}",
  			"gitPath: "${git_path}
  		}
	}"""

	response = httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'POST', 
				requestBody: body,
				ignoreSslErrors: true, 
				url: "${server}/rad/jc.api:api/tools/publish", 
				validResponseCodes: '200:201'

	jsn = readJSON file: '', text: "${response.content}"

	return jsn;
}

// Updates given attributes of API  in API Gateway
// Allows for existing API to be updated in relation to given meta-data, is_active, maturity and/or groups (string[])
def updateAPIAttributes(server, authorizer, api_name, api_version, is_active, maturity, groups) {

	def body = """ {
		"apiGatewayURL": "${APIGW_SERVER}",
		"apiGatewayCredentials": "${APIGW_CREDENTIALS}"
	} """

	headers = [];

	print("setting up headers");

	if (api_version != null) {
		headers.add([maskValue: false, name: 'apiVersion', value: api_version])
	}
	if (is_active != null) {
		headers.add([maskValue: false, name: 'isActive', value: is_active ? "true" : "false"])
	}

	if (maturity != null) {	
		headers.add([maskValue: false, name: 'maturity', value: maturity])
	}

	if (groups != null) {
		headers.add([maskValue: false, name: 'groups', value: groovy.json.JsonOutput.toJson(groups)])
	}

	httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'PATCH', 
				ignoreSslErrors: true, 
				requestBody: body, 
				customHeaders: headers,
				url: "${server}/rad/jc.api:api/tools/gateway/api?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}", 
				validResponseCodes: '200:201'
}

// Deploys API from an API Gateway, to another or Portal or both
// Can either stage, publish to portal or do both, depending on what attribute have been given.
//
def deployAPI(server, authorizer, stagedAuthorizer, api_name, api_version, stage_name, portal_name, portal_community) {

	def body = """ {
		"apiServer": {
			"apiGatewayURL": "${APIGW_SERVER}",
			"apiGatewayCredentials": "${APIGW_CREDENTIALS}"
  		},
  		"where": {
  			"stageName": "${stage_name}",
  			"portalName": "${portal_name}",
  			"communityName": "${portal_community}",
  			"apiGatewayCredentials": "${stagedAuthorizer}"
  		}
	}"""

	if (api_version)
		url = "${server}/rad/jc.api:api/tools/gateway/api?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}&apiVersion=${java.net.URLEncoder.encode(api_version, "UTF-8")}"
	else
		url = "${server}/rad/jc.api:api/tools/gateway/api?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}"

	httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'POST', 
				ignoreSslErrors: true, 
				requestBody: body, 
				url: url, 
				validResponseCodes: '200:201'
}

// Rollback previous deployment
// can only be used after above deploy function
def rollbackAPI(server, authorizer, stagedAuthorizer, api_name, api_version, stage_name, portal_name, portal_community) {

	def body = """ {
		"apiServer": {
			"apiGatewayURL": "${APIGW_SERVER}",
			"apiGatewayCredentials": "${APIGW_CREDENTIALS}"
  		},
  		"where": {
  			"stageName": "${stage_name}",
  			"portalName": "${portal_name}",
  			"communityName": "${portal_community}",
  			"apiGatewayCredentials": "${stagedAuthorizer}"
  		}
	}"""

	print("rollbacking with body:" + body);

	if (api_version)
		url = "${server}/rad/jc.api:api/tools/gateway/api?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}&apiVersion=${java.net.URLEncoder.encode(api_version, "UTF-8")}"
	else
		url = "${server}/rad/jc.api:api/tools/gateway/api?apiName=${java.net.URLEncoder.encode(api_name, "UTF-8")}"

	httpRequest acceptType: 'APPLICATION_JSON', 
				authentication: authorizer, 
				contentType: 'APPLICATION_JSON', 
				httpMode: 'DELETE', 
				ignoreSslErrors: true, 
				requestBody: body, 
				url: url, 
				validResponseCodes: '200:201'

}

// Run test stun for given API, 
def testAPI(apigwServer, testServer, apiRef) {

	// TODO:
}

def filterForNames(apis, filterNames) {

	def out = []

	apis.each { ref -> 
		
		if (filterNames.indexOf(ref.name) != -1) {
			out.add(ref);
		}			
	}

	return out;
}

///////////////////////////////////////////////////////////////
// Demonstration purposes ONLY
// 
// Below pipeline is for reference purposes only in order to show case above functions.
// Replace it with your pipeline.
//
// Fetch --> Register (API Gateway) ->- Update (meta-data) --> Deploy (Stage TEST/Portal) --> Test --- (ok) --> finalize
//																		   						   --- (ko) --> rollback
//
pipeline {
	agent any
	environment {
		
		INT_SERVER = 'http://host.docker.internal:5555'
		INT_AUTH = 'int-server'
		MATURITY = 'test'
		API_GROUP = "devops_demo"
		API_VERSION = "1.0"
		APP_NAME = "test_app"

		APIGW_SERVER = 'http://localhost:7777'
		APIGW_CREDENTIALS = credentials('api-gw-server')
		APIGW_ALLOW_UPDATE = false;
	}
	stages {
		stage('Fetch') {
			steps {
				script {
					
					apis = getServerAPIs(INT_SERVER, INT_AUTH);

					api_summary = null;
					apis.each { ref -> 

						if (api_summary == null)
							api_summary = "\"" + ref.name + "\"";
						else
							api_summary += ", \"" + ref.name + "\"";
					}
				}
			}
		}
		stage('Register') {
			steps {
				input("Following APIs have been found: " + api_summary)
				script {
					def userInput = input(
						id: 'apiInput', message: 'API Implementation endpoint', parameters: [
							[$class: 'TextParameterDefinition', defaultValue: "host.docker.internal:5555", description: 'API Endpoint', name: 'apiEndpoint'],
							[$class: 'TextParameterDefinition', defaultValue: api_summary, description: 'Confirm APIs', name: 'apis']
						])

					api_endpoint=userInput['apiEndpoint']
					api_summary=userInput['apis']
					api_confirm=readJSON file: '', text: "{\"list\": [${api_summary}]}"

					apis = filterForNames(apis, api_confirm.list)

					apis.each { ref ->

						print("registering " + ref.id)

						apisOut = registerServerAPI(INT_SERVER, INT_AUTH, ref.name, MATURITY, API_GROUP, API_VERSION, api_endpoint, APP_NAME)

						// ensures we are in sync version on API Gateway!!

						ref.id = apisOut[0].id
						ref.name = apisOut[0].apiName
						ref.version = apisOut[0].apiVersion

						print("got back id " + ref.id)
						print("got back apiName " + ref.name)
						print("got back version "  + ref.version)
						print("flange "+ ref);
					}
				}
			}
		}
		stage('Update') {
			steps {
				input("Will modify maturity & groups: " + api_summary)
				script {

					apis.each { ref -> 

						print("processing " + ref);

						updateAPIAttributes(INT_SERVER, INT_AUTH, ref.name, ref.version, true, "NEW", ["demo", "jc"])
					}
				}
			}
		}
		stage('Deploy') {
			environment {
				staged_auth_server = credentials("TEST-api-gw-server")
			}
			steps {
				input("Will now deploy APIs to API Gateway defined by stage TEST, and publish to its Portal " + api_summary)
				script {
					def userInput = input(
						id: 'apiInput', message: 'Portal Info', parameters: [
							[$class: 'TextParameterDefinition', defaultValue: "APIPortal", description: 'Portal Name', name: 'portal_name'],
							[$class: 'TextParameterDefinition', defaultValue: "Public Community", description: 'Community Name', name: 'community'],
						])

					portal_name=userInput['portal_name']
					portal_community=userInput['community']

					print("will leverage credentials " + staged_auth_server)

					apis.each { ref ->
						deployAPI(INT_SERVER, INT_AUTH, staged_auth_server, ref.name, ref.version, "TEST", portal_name, portal_community)
					}
				}
			}
		}
		stage('Test') {
			steps {
				input("Tested okay ?")
				script {

					def userInput = input(
						id: 'apiInput', message: 'Portal Info', parameters: [
							[$class: 'TextParameterDefinition', defaultValue: "true", description: 'Passed ?', name: 'passed']
						])

					passed=userInput;

					if (!passed.equals('true'))
						FAILED_APIS = apis;
				}
			}
		}
		stage('Rollback') {
			when {
				expression { FAILED_APIS.size() > 0 }
			}
			environment {
				staged_auth_server = credentials("TEST-api-gw-server")
			}
			steps {
				script {

					print("Rollbacking APIS from test environment: " + api_summary)


					apis.each { ref -> 

						rollbackAPI(INT_SERVER, INT_AUTH, staged_auth_server, ref.name, ref.version, "TEST", portal_name, portal_community)

						updateAPIAttributes(INT_SERVER, authorizer, ref.name, false, "failed", null)
					}
				}
			}
		}
		stage('Finalize') {
			when {
				expression { FAILED_APIS == null }
			}
			steps {
				script {
					print("Updating maturity to TESTED: " + api_summary)

					APIS.each { ref -> 
						updateAPIAttributes(INT_SERVER, INT_AUTH, ref.name, ref.version, true, "TESTED", null)
					}
				}
			}
		}
	}
}